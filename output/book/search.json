[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "w-python-numpy-grundlagen",
    "section": "",
    "text": "Preamble",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "w-python-numpy-grundlagen",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\n\nGrundlagen Python\nEinbinden von zusätzlichen Paketen\nPlotten mit Matplotlib",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#verwendete-pakete-und-datensätze",
    "href": "index.html#verwendete-pakete-und-datensätze",
    "title": "w-python-numpy-grundlagen",
    "section": "Verwendete Pakete und Datensätze",
    "text": "Verwendete Pakete und Datensätze\n\nPakete\n\nNumPy\nMatplotlib\n\n\n\nDatensätze\n\nTC01.csv\nBild: Mona Lisa\nBild: Campus",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#bearbeitungszeit",
    "href": "index.html#bearbeitungszeit",
    "title": "w-python-numpy-grundlagen",
    "section": "Bearbeitungszeit",
    "text": "Bearbeitungszeit\nGeschätzte Bearbeitungszeit: 2h",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "w-python-numpy-grundlagen",
    "section": "Lernziele",
    "text": "Lernziele\n\nEinleitung: was ist NumPy, Vor- und Nachteile\nNutzen des NumPy-Moduls\nErstellen von NumPy-Arrays\nSlicing\nLesen und schreiben von Dateien\nArbeiten mit Bildern",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "skript/introduction_en.html",
    "href": "skript/introduction_en.html",
    "title": "1  Introduction to NumPy",
    "section": "",
    "text": "1.1 Advantages & Disadvantages\nNumPy is a powerful library for Python that is used for numerical computing and data analysis. The name “NumPy” is an acronym for “Numerical Python”.\nNumPy itself is mainly written in the C programming language, which is why NumPy is generally very fast.\nNumPy allows efficient work with small and large vectors and matrices that would otherwise be cumbersome to implement in native Python. It also provides the ability to perform calculations with vectors and matrices easily—even for very large datasets.\nThis introduction will help you understand and use the basics of NumPy.\nIn most cases, operations with NumPy data structures are faster. However, unlike native Python lists, NumPy arrays can only hold one data type per list.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "skript/introduction_en.html#advantages-disadvantages",
    "href": "skript/introduction_en.html#advantages-disadvantages",
    "title": "1  Introduction to NumPy",
    "section": "",
    "text": "Why is NumPy often faster?\n\n\n\n\n\nNumPy implements a more efficient memory storage for lists.\nNative Python stores list contents in scattered memory locations, wherever space is available.\n\n\n\n\n\n\nFigure 1.1: Storage of data in native Python\n\n\n\nIn contrast, NumPy arrays and matrices are stored in contiguous blocks of memory, allowing for more efficient data access.\n\n\n\n\n\n\nFigure 1.2: Storage of data in NumPy\n\n\n\nHowever, this also means that expanding a list is much faster than expanding arrays or matrices. Lists can use any free space, while arrays and matrices have to be copied to a new location in memory.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "skript/introduction_en.html#importing-the-package",
    "href": "skript/introduction_en.html#importing-the-package",
    "title": "1  Introduction to NumPy",
    "section": "1.2 Importing the Package",
    "text": "1.2 Importing the Package\nNumPy is imported with the following line. It is a global convention to use the alias np.\n\nimport numpy as np",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "skript/introduction_en.html#references",
    "href": "skript/introduction_en.html#references",
    "title": "1  Introduction to NumPy",
    "section": "1.3 References",
    "text": "1.3 References\nAll functions introduced here can be found in the (English) NumPy documentation: Documentation",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to NumPy</span>"
    ]
  },
  {
    "objectID": "skript/array_creation_en.html",
    "href": "skript/array_creation_en.html",
    "title": "2  Creating NumPy Arrays",
    "section": "",
    "text": "In Python, vectors are typically represented by lists and matrices by nested lists. For example, the vector\n\n\n\n\n\n\n\\[\n(1, 2, 3, 4, 5, 6)\n\\]\n\n\nand the matrix\n\n\n\\[\n\\begin{pmatrix}\n1 & 2 & 3\\\\\n4 & 5 & 6\n\\end{pmatrix}\n\\]\n\n\n\ncan be natively created in Python like this:\n\nlst = [1, 2, 3, 4, 5, 6]\n\nmatrix = [[1, 2, 3], [4, 5, 6]]\n\nprint(lst)\nprint(matrix)\n\n[1, 2, 3, 4, 5, 6]\n[[1, 2, 3], [4, 5, 6]]\n\n\nIf you want to use NumPy arrays, you can use the np.array() command:\n\nlst = np.array([1, 2, 3, 4, 5, 6])\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(lst)\nprint(matrix)\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\nIf you look at the output from the print() commands, two things stand out. First, the commas are gone, and second, the matrix is printed in a clean, readable format.\nIt is also possible to create higher-dimensional arrays. This requires another level of nesting. In the following example, a three-dimensional matrix is created:\n\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nIt is considered good practice to always initialize arrays. NumPy offers three functions to create pre-initialized arrays. Alternatively, arrays can be initialized with fixed values. You can use np.zeros() to set all values to 0 or np.ones() to initialize all values with 1. These functions take the shape in the form [rows, columns]. If you want to initialize all elements with a specific value, use the np.full() function.\n\nnp.zeros([2,3])\n\narray([[0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones([2,3])\n\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.full([2,3],7)\n\narray([[7, 7, 7],\n       [7, 7, 7]])\n\n\n\n\n\n\n\n\nHow could you create arrays filled with a specific value x?\n\n\n\n\n\nThe trick is to initialize an array with np.ones() and then multiply the array by the number x. In the following example, x = 5:\n\nnp.ones([2,3]) * 5\n\narray([[5., 5., 5.],\n       [5., 5., 5.]])\n\n\n\n\n\nIf you want to create a vector with evenly spaced values, e.g., for an axis in a plot, NumPy offers two options. Use np.linspace(start, stop, #values) or np.arange(start, stop, step) to generate such arrays.\n\nnp.linspace(0,1,11)\n\narray([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])\n\n\n\nnp.arange(0,10,2)\n\narray([0, 2, 4, 6, 8])\n\n\n\n\n\n\n\n\nPractice Exercise: Array Creation\n\n\n\n\n\nCreate one NumPy array for each of the following tasks:\n\nwith the values 1, 7, 42, 99\n\nten times the number 5\n\nwith numbers from 35 up to and including 50\n\nwith all even numbers from 20 up to and including 40\n\na matrix with 5 columns and 4 rows filled with the value 4\n\nwith 10 values evenly spaced from 22 up to and including 40\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# 1. \nprint(np.array([1, 7, 42, 99]))\n\n[ 1  7 42 99]\n\n\n\n# 2. \nprint(np.full(10,5))\n\n[5 5 5 5 5 5 5 5 5 5]\n\n\n\n# 3. \nprint(np.arange(35, 51))\n\n[35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50]\n\n\n\n# 4. \nprint(np.arange(20, 41, 2))\n\n[20 22 24 26 28 30 32 34 36 38 40]\n\n\n\n# 5. \nprint(np.full([4,5],4))\n\n[[4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]]\n\n\n\n# 6. \nprint(np.linspace(22, 40, 10))\n\n[22. 24. 26. 28. 30. 32. 34. 36. 38. 40.]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Creating NumPy Arrays</span>"
    ]
  },
  {
    "objectID": "skript/array_info_en.html",
    "href": "skript/array_info_en.html",
    "title": "3  Size, Structure, and Type",
    "section": "",
    "text": "If you’re unsure about the structure or shape of an array, or if you want to use this information for loops, NumPy offers the following functions to retrieve it:\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\nnp.shape() returns the length of each dimension in the form of a tuple.\n\nnp.shape(matrix)\n\n(2, 3)\n\n\nThe native Python function len() only returns the length of the first dimension, i.e., the number of elements in the outer brackets. In the example above, len() sees the two lists [1, 2, 3] and [4, 5, 6].\n\nlen(matrix)\n\n2\n\n\nThe function np.ndim() returns the number of dimensions, unlike np.shape().\n\nnp.ndim(matrix)\n\n2\n\n\n\n\n\n\n\n\nThe output of np.ndim() can also be derived using np.shape() and a native Python function. How?\n\n\n\n\n\nnp.ndim() simply returns the length of the tuple from np.shape():\n\nlen(np.shape(matrix))\n\n2\n\n\n\n\n\nIf you want to know the total number of elements in an array, you can use the function np.size().\n\nnp.size(matrix)\n\n6\n\n\nNumPy arrays can contain various data types. Below we have three different arrays with different data types:\n\ntyp_a = np.array([1, 2, 3, 4, 5])\ntyp_b = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\ntyp_c = np.array([\"Monday\", \"Tuesday\", \"Wednesday\"])\n\nWith the method np.dtype, we can retrieve the data type of arrays. Usually, this returns the type along with a number that represents the number of bytes needed to store the values. The array typ_a has the data type int64, meaning whole numbers.\n\nprint(typ_a.dtype)\n\nint64\n\n\nThe array typ_b has the data type float64, where float represents floating-point numbers.\n\nprint(typ_b.dtype)\n\nfloat64\n\n\nThe array typ_c has the data type U8, where U stands for Unicode. The text is stored in Unicode format.\n\nprint(typ_c.dtype)\n\n&lt;U9\n\n\nBelow is a table of typical data types you’ll commonly encounter in NumPy:\n\n\n\n\n\n\nData Type\nNumPy Name\nExamples\n\n\n\n\nBoolean\nbool\n[True, False, True]\n\n\nInteger\nint\n[-2, 5, -6, 7, 3]\n\n\nUnsigned Integer\nuint\n[1, 2, 3, 4, 5]\n\n\nFloating Point\nfloat\n[1.3, 7.4, 3.5, 5.5]\n\n\nComplex Numbers\ncomplex\n[-1 + 9j, 2 - 77j, 72 + 11j]\n\n\nText (Unicode)\nU\n[“monday”, “tuesday”]\n\n\n\n\n\nTable 3.1: Typical Data Types in NumPy\n\n\n\n\n\n\n\n\n\nIntermediate Exercise: Reading Array Information\n\n\n\n\n\nGiven the following matrix:\n\nmatrix = np.array([[[ 0,  1,  2,  3],\n                    [ 4,  5,  6,  7],\n                    [ 8,  9, 10, 11]],\n\n                   [[12, 13, 14, 15],\n                    [16, 17, 18, 19],\n                    [20, 21, 22, 23]],\n\n                   [[24, 25, 26, 27],\n                    [28, 29, 30, 31],\n                    [32, 33, 34, 35]]])\n\nVisually determine the number of dimensions and the length of each dimension. What is the data type of the elements in this matrix?\nThen verify your results by applying the appropriate NumPy functions.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmatrix = np.array([[[ 0,  1,  2,  3],\n                    [ 4,  5,  6,  7],\n                    [ 8,  9, 10, 11]],\n\n                   [[12, 13, 14, 15],\n                    [16, 17, 18, 19],\n                    [20, 21, 22, 23]],\n\n                   [[24, 25, 26, 27],\n                    [28, 29, 30, 31],\n                    [32, 33, 34, 35]]])\n\nnum_dimensions = np.ndim(matrix)\nprint(\"Number of dimensions: \", num_dimensions)\n\ndimension_lengths = np.shape(matrix)\nprint(\"Lengths of each dimension: \", dimension_lengths)\n\nprint(matrix.dtype)\n\nNumber of dimensions:  3\nLengths of each dimension:  (3, 3, 4)\nint64",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Size, Structure, and Type</span>"
    ]
  },
  {
    "objectID": "skript/array_calculation_en.html",
    "href": "skript/array_calculation_en.html",
    "title": "4  Working with Arrays",
    "section": "",
    "text": "4.1 Arithmetic Functions\nOne major advantage of NumPy is working with arrays. Without NumPy, you would either have to use a loop or a list comprehension to perform operations on all values in a list. NumPy eliminates this inconvenience.\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 8, 7, 6, 5])\nBasic mathematical operations like addition can be expressed in two ways: either using the np.add() function or simply with the + operator.\nnp.add(a,b)\n\narray([10, 10, 10, 10, 10])\na + b\n\narray([10, 10, 10, 10, 10])\nWithout NumPy, the operation would look like this:\nresult = np.ones(5)\nfor i in range(len(a)):\n    result[i] = a[i] + b[i]\n\nprint(result)\n\n[10. 10. 10. 10. 10.]\nFor other types of arithmetic, there are functions like: np.subtract(), np.multiply(), and np.divide().\nHigher-level mathematical operations also have functions:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "skript/array_calculation_en.html#arithmetic-functions",
    "href": "skript/array_calculation_en.html#arithmetic-functions",
    "title": "4  Working with Arrays",
    "section": "",
    "text": "np.exp(a)\nnp.sqrt(a)\nnp.power(a, 3)\nnp.sin(a)\nnp.cos(a)\nnp.tan(a)\nnp.log(a)\na.dot(b)\n\n\n\n\n\n\n\nWorking with Trigonometric Functions\n\n\n\nJust like with a calculator, a common error when using trigonometric functions (sin, cos, …) is to input degrees instead of radians. However, the trigonometric functions in NumPy expect values in radians.\nTo easily convert between degrees and radians, NumPy provides the functions np.deg2rad() and np.rad2deg().",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "skript/array_calculation_en.html#comparisons",
    "href": "skript/array_calculation_en.html#comparisons",
    "title": "4  Working with Arrays",
    "section": "4.2 Comparisons",
    "text": "4.2 Comparisons\nNumPy arrays can also be compared with one another. Let’s look at the following two arrays:\n\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 2, 7, 4, 5])\n\nTo check whether these arrays are identical, we can use the == comparator. This compares the arrays element-wise.\n\na == b\n\narray([False,  True, False,  True,  True])\n\n\nYou can also compare arrays using the &gt; and &lt; operators:\n\na &lt; b\n\narray([ True, False,  True, False, False])\n\n\nWhen comparing arrays with floating point numbers, it is often necessary to allow for some tolerance due to small rounding errors in computations.\n\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\na == b\n\nnp.False_\n\n\nFor this case, NumPy offers a comparison function np.isclose(a,b,atol), where atol stands for absolute tolerance. In the following example, an absolute tolerance of 0.001 is used.\n\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\nprint(np.isclose(a, b, atol=0.001))\n\nTrue\n\n\n\n\n\n\n\n\nWhy is 0.1 + 0.2 not equal to 0.3?\n\n\n\n\n\nNumbers are internally represented in binary. Just like 1/3 cannot be represented precisely with a finite number of decimal digits, some numbers must be rounded in binary representation.\n\na = 0.1\nb = 0.2\nprint(a + b)\n\n0.30000000000000004",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "skript/array_calculation_en.html#aggregation-functions",
    "href": "skript/array_calculation_en.html#aggregation-functions",
    "title": "4  Working with Arrays",
    "section": "4.3 Aggregation Functions",
    "text": "4.3 Aggregation Functions\nFor many types of analysis, we need functions such as sum or mean. Let’s start with an example array a:\n\na = np.array([1, 2, 3, 4, 8])\n\nThe sum is calculated using the np.sum() function.\n\nnp.sum(a)\n\nnp.int64(18)\n\n\nOf course, you can also determine the minimum and maximum of an array. The functions are np.min() and np.max().\n\nnp.min(a)\n\nnp.int64(1)\n\n\nIf you want the position of the maximum value instead of the value itself, use np.argmax instead of np.max.\nFor statistical analysis, common functions are np.mean() for the mean, np.median() for the median, and np.std() for the standard deviation.\n\nnp.mean(a)\n\nnp.float64(3.6)\n\n\n\nnp.median(a)\n\nnp.float64(3.0)\n\n\n\nnp.std(a)\n\nnp.float64(2.4166091947189146)\n\n\n\n\n\n\n\n\nExercise: Working with Arrays\n\n\n\n\n\nGiven two one-dimensional arrays a and b:\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) and\nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\nCreate a new array that contains the sine values of the added arrays a and b.\nCalculate the sum, mean, and standard deviation of the elements in a.\nFind the largest and smallest values in both a and b.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n# 1.\nsin_ab = np.sin(a + b)\n\n# 2.\nsum_a = np.sum(a)\nmean_a = np.mean(a)\nstd_a = np.std(a)\n\n# 3.\nmax_a = np.max(a)\nmin_a = np.min(a)\nmax_b = np.max(b)\nmin_b = np.min(b)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Working with Arrays</span>"
    ]
  },
  {
    "objectID": "skript/array_slicing_en.html",
    "href": "skript/array_slicing_en.html",
    "title": "5  Slicing",
    "section": "",
    "text": "5.1 Basic Slicing with Numeric Indices\nTo select data within an array, use the following formats:\nlist = np.array([1, 2, 3, 4, 5, 6])\n# Selecting the first element\nlist[0]\n\nnp.int64(1)\n# Selecting the last element\nlist[-1]\n\nnp.int64(6)\n# Selecting a range of elements\nlist[1:4]\n\narray([2, 3, 4])\nFor two-dimensional arrays, you use a comma to separate the selection along the first and second dimensions.\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n# Selecting a single element\nmatrix[1,1]\n\nnp.int64(5)\nFor three-dimensional arrays, an additional index is used, again separated by commas. The order remains: first, second, then third dimension.\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(matrix_3d)\n\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n# Selecting a specific element\nmatrix_3d[1,0,2]\n\nnp.int64(9)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "skript/array_slicing_en.html#basic-slicing-with-numeric-indices",
    "href": "skript/array_slicing_en.html#basic-slicing-with-numeric-indices",
    "title": "5  Slicing",
    "section": "",
    "text": "Figure 5.1: Accessing individual axes for one-, two-, and three-dimensional arrays including examples\n\n\n\n\n\n[a] returns the single value at position a\n[a:b] returns all values from position a up to (but not including) b\n[a:b:c] returns values from position a to b-1 in steps of c",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "skript/array_slicing_en.html#slicing-with-boolean-values-boolean-masking",
    "href": "skript/array_slicing_en.html#slicing-with-boolean-values-boolean-masking",
    "title": "5  Slicing",
    "section": "5.2 Slicing with Boolean Values (Boolean Masking)",
    "text": "5.2 Slicing with Boolean Values (Boolean Masking)\nBoolean slicing uses a boolean mask to select specific elements from an array. The mask is an array of the same length as the original, consisting of True or False values.\n\n# Create a sample array\na = np.array([1, 2, 3, 4, 5, 6])\n\n# Create the mask\nmaske = a &gt; 3\n\nprint(maske)\n\n[False False False  True  True  True]\n\n\nThis results in an array of boolean values. Applying this mask to the original array returns all elements where the mask is True.\n\n# Applying the mask\nprint(a[maske])\n\n[4 5 6]\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUsing boolean arrays is only possible with the NumPy module. This approach cannot be applied to native Python lists. In such cases, you must iterate over the list manually.\n\na = [1, 2, 3, 4, 5, 6]\nresult = [x for x in a if x &gt; 3]\nprint(result) \n\n[4, 5, 6]\n\n\n\n\n\n\n\n\n\n\nMini Exercise: Array Slicing\n\n\n\n\n\nSelect the colored sections of the array matrix using the slicing techniques you just learned.\n\n\nmatrix = np.array([\n    [2, 11, 18, 47, 33, 48, 9, 31, 8, 41],\n    [55, 1, 8, 3, 91, 56, 17, 54, 23, 12],\n    [19, 99, 56, 72, 6, 13, 34, 16, 77, 56],\n    [37, 75, 67, 5, 46, 98, 57, 19, 14, 7],\n    [4, 57, 32, 78, 56, 12, 43, 61, 3, 88],\n    [96, 16, 92, 18, 50, 90, 35, 15, 36, 97],\n    [75, 4, 38, 53, 1, 79, 56, 73, 45, 56],\n    [15, 76, 11, 93, 87, 8, 2, 58, 86, 94],\n    [51, 14, 60, 57, 74, 42, 59, 71, 88, 52],\n    [49, 6, 43, 39, 17, 18, 95, 6, 44, 75]\n])\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nRed: matrix[1,3]\nGreen: matrix[4:6,2:6]\nPink: matrix[:,7]\nOrange: matrix[7,:5]\nBlue: matrix[-1,-1]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "skript/array_manipulation_en.html",
    "href": "skript/array_manipulation_en.html",
    "title": "6  Array Manipulation",
    "section": "",
    "text": "6.1 Changing the Shape\nVarious functions allow us to change the shape and contents of arrays.\nOne of the most important array operations is transposing. This operation switches rows with columns and vice versa.\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrix)\n\n[[1 2 3]\n [4 5 6]]\nIf we now transpose this array, we get:\nprint(np.transpose(matrix))\n\n[[1 4]\n [2 5]\n [3 6]]\nIf we have this matrix and want to turn it into a vector, we can use the np.flatten() function:\nvector = matrix.flatten()\nprint(vector)\n\n[1 2 3 4 5 6]\nTo return to a two-dimensional data structure, we use the function np.reshape(target, shape):\nprint(np.reshape(matrix, [3, 2]))\n\n[[1 2]\n [3 4]\n [5 6]]\nIf we want to expand, shrink, or modify the content of an existing array, NumPy also provides suitable functions.\nIf we have an empty array or want to add elements to an existing array, we use the np.append() function. This function appends a value to the existing array.\narray = np.array([1, 2, 3, 4, 5, 6])\n\nnew_array = np.append(array, 7)\nprint(new_array)\n\n[1 2 3 4 5 6 7]\nSometimes we need to insert a value not at the end but at a specific position in the array. The appropriate tool here is the function np.insert(array, position, insertion). In the following example, the number 7 is inserted at the third position.\narray = np.array([1, 2, 3, 4, 5, 6])\n\nnew_array = np.insert(array, 3, 7)\nprint(new_array)\n\n[1 2 3 7 4 5 6]\nJust like we can insert new elements, we can also delete elements. For this, we use the function np.delete(array, position), which takes the array and the position of the element to delete.\narray = np.array([1, 2, 3, 4, 5, 6])\n\nnew_array = np.delete(array, 3)\nprint(new_array)\n\n[1 2 3 5 6]\nLastly, let’s look at joining two arrays. In the following example, array b is appended to array a using the function np.concatenate((array a, array b)).\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.array([7, 8, 9, 10])\n\nnew_array = np.concatenate((a, b))\nprint(new_array)\n\n[ 1  2  3  4  5  6  7  8  9 10]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "skript/array_manipulation_en.html#sorting-arrays",
    "href": "skript/array_manipulation_en.html#sorting-arrays",
    "title": "6  Array Manipulation",
    "section": "6.2 Sorting Arrays",
    "text": "6.2 Sorting Arrays\nNumPy also provides the ability to sort arrays. In the following example, we start with an unsorted array. Using the np.sort() function, we obtain a sorted array.\n\nimport numpy as np\nunsorted = np.array([4, 2, 1, 6, 3, 5])\n\nsorted_array = np.sort(unsorted)\n\nprint(sorted_array)\n\n[1 2 3 4 5 6]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "skript/array_manipulation_en.html#sublists-with-unique-values",
    "href": "skript/array_manipulation_en.html#sublists-with-unique-values",
    "title": "6  Array Manipulation",
    "section": "6.3 Sublists with Unique Values",
    "text": "6.3 Sublists with Unique Values\nWhen working with data where, for example, projects are assigned employee IDs, there may be a finite number of employee IDs that appear multiple times if an employee works on several projects.\nIf we want a list where each number appears only once, we can use the np.unique function.\n\nimport numpy as np\nlist_with_duplicates = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\nunique_values = np.unique(list_with_duplicates)\n\nprint(unique_values)\n\n[1 3 4 6 7]\n\n\nIf we also set the option return_counts=True, a second variable will store how often each value occurs.\n\nimport numpy as np\nlist_with_duplicates = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\nunique_values, counts = np.unique(list_with_duplicates, return_counts=True)\n\nprint(counts)\n\n[2 3 2 1 1]\n\n\n\n\n\n\n\n\nMini Exercise: Array Manipulation\n\n\n\n\n\nGiven the following two-dimensional array named matrix:\n\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n\n\nChange the shape of the array matrix into a one-dimensional array.\nSort the one-dimensional array in ascending order.\nChange the shape of the sorted array into a two-dimensional array with 2 rows and 6 columns.\nDetermine the unique elements in the original array matrix and print them.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n\n# 1. Change to a one-dimensional array\nflat_array = matrix.flatten()\n\n# 2. Sort the one-dimensional array in ascending order\nsorted_array = np.sort(flat_array)\n\n# 3. Reshape the sorted array into a 2x6 array\nreshaped_array = sorted_array.reshape(2, 6)\n\n# 4. Find the unique elements in the original array\nunique_elements_original = np.unique(matrix)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "skript/array_read_n_write_en.html",
    "href": "skript/array_read_n_write_en.html",
    "title": "7  Reading and Writing Files",
    "section": "",
    "text": "7.1 Reading Files\nThe numpy module provides functions for reading and writing structured text files.\nTo read structured text files, such as CSV (comma-separated values) files, the np.loadtxt() function can be used. It takes the filename to be read as its main argument, along with other options to define the data structure. The return value is a (multi-dimensional) array.\nIn the following example, the file TC01.csv is read and its contents are plotted. The first line of the file is ignored, as it is interpreted as a comment (starting with the # character).\nfilename = '01-daten/TC01.csv'\ndata = np.loadtxt(filename)\nprint(\"Data:\", data)\nprint(\"Shape:\", data.shape)\n\nData: [20.1 20.1 20.1 ... 24.3 24.2 24.2]\nShape: (1513,)\nplt.plot(data)\nplt.xlabel('Data Index')\nplt.ylabel('Temperature in °C');\nBy default, the np.loadtxt() function expects comma-separated values. If the data is separated by a different character, the delimiter = \"\" option can be used to specify a different delimiter. For example, if the separator is a semicolon, the function call would look like: np.loadtxt(data.txt, delimiter = \";\")\nIf the file starts with lines containing additional information such as units or experiment details, these can be skipped using the skiprows= #rows option.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "skript/array_read_n_write_en.html#writing-files",
    "href": "skript/array_read_n_write_en.html#writing-files",
    "title": "7  Reading and Writing Files",
    "section": "7.2 Writing Files",
    "text": "7.2 Writing Files\nTo write arrays to files, you can use the np.savetxt() function available in numpy. At a minimum, it requires the array to be written and a filename. Numerous formatting and structuring options are also available.\nThe following example scales the data read earlier and writes every tenth value to a new file. A comment (header argument) is also added at the beginning of the file. The output format of the numbers can be specified using the fmt argument. The format is similar to the formatting style used in formatted strings.\n\nvalue_range = np.max(data) - np.min(data)\ndata_scaled = (data - np.min(data)) / value_range\ndata_scaled = data_scaled[::10]\n\n\nplt.plot(data_scaled)\nplt.xlabel('Data Index')\nplt.ylabel('Scaled Temperature');\n\n\n\n\n\n\n\n\nWhen writing the file, a multi-line comment is defined using the newline character \\n. The floating-point numbers are formatted with %5.2f, which means 5 total characters with 2 digits after the decimal point.\n\n# Assignment is split into multiple lines due to the narrow display in the script\ncomment = f'Data from {filename} scaled to the range ' + \\\n           '0 to 1 \\noriginal min / max: ' + \\\n           f'{np.min(data)}/{np.max(data)}'\nnew_filename = '01-daten/TC01_scaled.csv'\n\nnp.savetxt(new_filename, data_scaled, \n           header=comment, fmt='%5.2f')\n\nTo illustrate, the first lines of the newly created file are printed.\n\n# Read the first lines of the newly created file\nfile = open(new_filename, 'r')\nfor i in range(10):\n    print(file.readline(), end='')\nfile.close()\n\n# Data from 01-daten/TC01.csv scaled to the range 0 to 1 \n# original min / max: 20.1/31.1\n 0.00\n 0.00\n 0.00\n 0.01\n 0.01\n 0.01\n 0.01\n 0.01",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reading and Writing Files</span>"
    ]
  },
  {
    "objectID": "skript/array_images_en.html",
    "href": "skript/array_images_en.html",
    "title": "8  Working with Images",
    "section": "",
    "text": "Images are digitally stored as matrices. Each pixel contains three color values: red, green, and blue. These three values (ranging from 0–255) are combined to produce all desired colors.\n\n\n\n\n\n\nFigure 8.1: A high-resolution image consists of many pixels. Each pixel contains 3 color values: one each for green, blue, and red.\n\n\n\nThanks to the digital nature of images, they can be easily processed using NumPy tools. In the following example, we use the Mona Lisa as our image. It can be found at this link.\nLet’s import this image using the imread() function from the matplotlib package. You’ll see that it is a three-dimensional NumPy array.\n\nimport matplotlib.pyplot as plt\n\ndata = plt.imread(\"00-bilder/mona_lisa.jpg\")\nprint(\"Shape:\", data.shape)\n\nShape: (1024, 677, 3)\n\n\nLet’s take a look at a snippet of the data using the print() function.\n\nprint(data)\n\n[[[ 68  62  38]\n  [ 88  82  56]\n  [ 92  87  55]\n  ...\n  [ 54  97  44]\n  [ 68 110  60]\n  [ 69 111  63]]\n\n [[ 65  59  33]\n  [ 68  63  34]\n  [ 83  78  46]\n  ...\n  [ 66 103  51]\n  [ 66 103  52]\n  [ 66 102  56]]\n\n [[ 97  90  62]\n  [ 87  80  51]\n  [ 78  72  38]\n  ...\n  [ 79 106  53]\n  [ 62  89  38]\n  [ 62  88  41]]\n\n ...\n\n [[ 25  14  18]\n  [ 21  10  14]\n  [ 20   9  13]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 23  12  16]\n  [ 23  12  16]\n  [ 21  10  14]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 22  11  15]\n  [ 26  15  19]\n  [ 24  13  17]\n  ...\n  [ 11   5   9]\n  [ 10   4   8]\n  [  9   3   7]]]\n\n\nUsing the plt.imshow function, the image can be displayed in true color. This works because the function interprets the last index of the dataset as color information (red, green, blue). If there were a fourth layer, it would be interpreted as an individual transparency value.\n\nplt.imshow(data)\n\n\n\n\n\n\n\n\nOf course, the individual color channels can also be viewed separately. We do this by fixing the last index. Here we look only at the red component of the image. When displaying a simple array, the output is in grayscale. With the option cmap='Reds', we can adjust the color scale.\n\n# Use the red color scale 'Reds'\nplt.imshow(data[:,:,0], cmap='Reds')\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n\n\nSince the image data is stored as arrays, many operations such as slicing or other computations are possible. The example below shows a cropped area of the red channel.\n\nregion = np.array(data[450:500, 550:600, 0], dtype=float)\nplt.imshow(region, cmap=\"Greys\")\nplt.colorbar()\n\n\n\n\n\n\n\n\nNow let’s consider a more complex operation on image data, the Laplace operator. It can be used to detect the edges of objects. For each pixel \\(B_{i,j}\\) – except those at the border – the following value \\(\\phi_{i,j}\\) is computed:\n\\[ \\phi_{i, j} = \\left|B_{i-1, j} + B_{i, j-1} - 4\\cdot B_{i, j} + B_{i+1, j} + B_{i, j+1}\\right| \\]\nThe following function implements this operation. In addition, all values of \\(\\phi\\) below a threshold are set to zero, and those above are set to 255.\n\ndef img_lap(data, threshold=25):\n    \n    # Create a copy of the data as a float array\n    region = np.array(data, dtype=float)\n    \n    # Split the equation into two parts\n    lapx = region[2:, :] - 2 * region[1:-1, :] + region[:-2, :]\n    lapy = region[:, 2:] - 2 * region[:, 1:-1] + region[:, :-2]\n    \n    # Combine the parts and take the absolute value\n    lap = np.abs(lapx[:,1:-1] + lapy[1:-1, :])\n    \n    # Thresholding\n    lap[lap &gt; threshold] = 255\n    lap[lap &lt; threshold] = 0\n    \n    return lap\n\nNow let’s examine a photo of the Haspel Campus in Wuppertal: Image. Applying the Laplace operator to a cropped section gives the following result:\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\nregion = np.array(data[1320:1620, 400:700, 1], dtype=float)\n\nlap = img_lap(region)\n\nplt.figure(figsize=(9, 3))\n\nax = plt.subplot(1, 3, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 3, 2)\nax.imshow(region, cmap=\"Greys_r\");\n\nax = plt.subplot(1, 3, 3)\nax.imshow(lap, cmap=\"Greys\");\n\n\n\n\n\n\n\n\nWe can now clearly see the outlines of the window.\nIf we want to edit a color component and then reassemble the image, we use the function np.dstack((red, green, blue)).astype('uint8'), where red, green, and blue are the individual 2D arrays. Let’s try removing the green color from the tree on the left.\nIt’s important that the data is in uint8 format after recombining, which is why we use .astype('uint8').\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\n# Store individual color channels in arrays\nred = np.array(data[:, :, 0], dtype=float)\ngreen = np.array(data[:, :, 1], dtype=float)\nblue = np.array(data[:, :, 2], dtype=float)\n\n# Set the green area of the tree on the left to 0\ngreen_new = green.copy()\ngreen_new[800:2000, 700:1700] = 0\n\ncomposed = np.dstack((red, green_new, blue)).astype('uint8')\n\nplt.figure(figsize=(8, 5))\n\nax = plt.subplot(1, 2, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 2, 2)\nax.imshow(composed)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMini Exercise: Image Manipulation\n\n\n\n\n\nLoad the following image of the Haspel Campus in Wuppertal:\nImage\nExtract the blue component and display the middle row of the image, as well as any selected image section.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\nshape = data.shape\nprint(\"Shape:\", shape)\n\nblue = data[:,:,2]\nplt.imshow(blue, cmap='Blues')\n\nrow = data[int(shape[0]/2), :, 2]\nprint(row)\n\ncrop = data[10:50, 10:50, :]\nplt.imshow(crop)\n\nShape: (3024, 4032, 3)\n[221 220 220 ...  28  28  28]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Images</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html",
    "href": "skript/assessment_en.html",
    "title": "9  Learning Objective Check",
    "section": "",
    "text": "Task 1\nWelcome to the learning objective check!\nThis self-assessment is designed to help you review your understanding of the topics covered so far and to allow you to independently evaluate your learning progress. It is structured so that you can identify your strengths and weaknesses and work specifically on areas that still need improvement.\nYou have two options to test your knowledge. You can use the quiz, which will guide you automatically through the different topics. Alternatively, you will find standard questions below, similar to those used in the script so far.\nPlease take enough time to work through the questions calmly. Be honest with yourself and try to solve the tasks without any aids in order to get a realistic picture of your current level of knowledge. If you encounter difficulties with a question, it is an indication that you should practice more in that area.\nGood luck with the exercises and your continued learning!\nHow is the NumPy package typically imported?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-2",
    "href": "skript/assessment_en.html#task-2",
    "title": "9  Learning Objective Check",
    "section": "Task 2",
    "text": "Task 2\nUse NumPy to create the following arrays:\n\nConvert the list [1, 2, 3] into a NumPy array\n\nA one-dimensional array containing the numbers from 0 to 9\n\nA two-dimensional array of shape 3×33×3 filled with ones\n\nA one-dimensional array containing numbers from 10 to 50 (inclusive) in steps of 5",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-3",
    "href": "skript/assessment_en.html#task-3",
    "title": "9  Learning Objective Check",
    "section": "Task 3",
    "text": "Task 3\nWhat is the difference between the functions np.ndim, np.shape, and np.size?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-4",
    "href": "skript/assessment_en.html#task-4",
    "title": "9  Learning Objective Check",
    "section": "Task 4",
    "text": "Task 4\nWhat data type does the following array have? Which function can be used to read the data type of an array?\n\nvector = np.array([ 4.8,  8.2, 15.6, 16.6, 23.2, 42.8 ])",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-5",
    "href": "skript/assessment_en.html#task-5",
    "title": "9  Learning Objective Check",
    "section": "Task 5",
    "text": "Task 5\nPerform the following mathematical operations on these two arrays:\na = [5, 1, 3, 6, 4] and b = [6, 5, 2, 6, 9]\n\nAdd both arrays\n\nCalculate the element-wise product of a and b\n\nAdd 3 to each entry in array a",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-6",
    "href": "skript/assessment_en.html#task-6",
    "title": "9  Learning Objective Check",
    "section": "Task 6",
    "text": "Task 6\na = [9, 2, 3, 1, 3]\n\nCalculate the mean and standard deviation of array a\n\nDetermine the minimum and maximum of the array",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-7",
    "href": "skript/assessment_en.html#task-7",
    "title": "9  Learning Objective Check",
    "section": "Task 7",
    "text": "Task 7\n\nmatrix = np.array([\n    [ 1,  2,  3,  4,  5],\n    [ 6,  7,  8,  9, 10],\n    [11, 12, 13, 14, 15],\n    [16, 17, 18, 19, 20],\n    [21, 22, 23, 24, 25]\n])\n\n\nExtract the first row\n\nExtract the last column\n\nExtract the submatrix consisting of rows 2 to 4 and columns 1 to 3",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-8",
    "href": "skript/assessment_en.html#task-8",
    "title": "9  Learning Objective Check",
    "section": "Task 8",
    "text": "Task 8\n\narray = np.arange(1, 21)\n\n\nReshape the array into a two-dimensional matrix with shape 4×5\n\nReshape the array into a two-dimensional matrix with shape 5×4\n\nReshape the array into a three-dimensional matrix with shape 2×2×5\n\nFlatten the three-dimensional array from Task 3 back into a one-dimensional array\n\nTranspose the 4×5 matrix from Task 1",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-9",
    "href": "skript/assessment_en.html#task-9",
    "title": "9  Learning Objective Check",
    "section": "Task 9",
    "text": "Task 9\nWhich two functions can be used to read data from a file and save data to a file?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "skript/assessment_en.html#task-10",
    "href": "skript/assessment_en.html#task-10",
    "title": "9  Learning Objective Check",
    "section": "Task 10",
    "text": "Task 10\nYou want to isolate the pixel data of one color channel from an image. What do you need to do?\n\n\n\n\n\n\nSolutions\n\n\n\n\n\n\nTask 1\n\nimport numpy as np\n\n\n\nTask 2\n\n# 1.\nnp.array([1, 2, 3])\n\n# 2.\nprint(np.arange(10))\n\n# 3.\nprint(np.ones((3, 3)))\n\n# 4.\nprint(np.arange(10, 51, 5))\n\n[0 1 2 3 4 5 6 7 8 9]\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n[10 15 20 25 30 35 40 45 50]\n\n\n\n\nTask 3\n\nnp.ndim: Returns the number of dimensions\n\nnp.shape: Returns the lengths of each dimension\n\nnp.size: Returns the total number of elements\n\n\n\nTask 4\nSince these are floating-point numbers, the data type is float64.\n\nvector = np.array([ 4.8,  8.2, 15.6, 16.6, 23.2, 42.8 ])\nprint(vector.dtype)\n\nfloat64\n\n\n\n\nTask 5\n\na = np.array([5, 1, 3, 6, 4])\nb = np.array([6, 5, 2, 6, 9])\n\n# 1.\nresult = a + b\nprint(\"The sum of both vectors is:\", result)\n\n# 2.\nresult = a * b\nprint(\"The product of both vectors is:\", result)\n\n# 3.\nresult = a + 3\nprint(\"a plus 3 is:\", result)\n\nThe sum of both vectors is: [11  6  5 12 13]\nThe product of both vectors is: [30  5  6 36 36]\na plus 3 is: [8 4 6 9 7]\n\n\n\n\nTask 6\n\na = np.array([9, 2, 3, 1, 3])\n\n# 1.\nmean = np.mean(a)\nprint(\"Mean:\", mean)\n\nstd_dev = np.std(a)\nprint(\"Standard deviation:\", std_dev)\n\n# 2.\nminimum = np.min(a)\nprint(\"Minimum:\", minimum)\n\nmaximum = np.max(a)\nprint(\"Maximum:\", maximum)\n\nMean: 3.6\nStandard deviation: 2.8000000000000003\nMinimum: 1\nMaximum: 9\n\n\n\n\nTask 7\n\nmatrix = np.array([\n    [ 1,  2,  3,  4,  5],\n    [ 6,  7,  8,  9, 10],\n    [11, 12, 13, 14, 15],\n    [16, 17, 18, 19, 20],\n    [21, 22, 23, 24, 25]\n])\n\n# 1. First row\nprint(matrix[0, :])\n\n# 2. Last column\nprint(matrix[:, -1])\n\n# 3. Submatrix from rows 2 to 4 and columns 1 to 3\nprint(matrix[1:4, 0:3])\n\n[1 2 3 4 5]\n[ 5 10 15 20 25]\n[[ 6  7  8]\n [11 12 13]\n [16 17 18]]\n\n\n\n\nTask 8\n\narray = np.arange(1, 21)\n\n# 1. Reshape to 4x5\nmatrix_4x5 = array.reshape(4, 5)\n\n# 2. Reshape to 5x4\nmatrix_5x4 = array.reshape(5, 4)\n\n# 3. Reshape to 2x2x5\nmatrix_2x2x5 = array.reshape(2, 2, 5)\n\n# 4. Flatten\nflattened_array = matrix_2x2x5.flatten()\n\n# 5. Transpose the 4x5 matrix\ntransposed_matrix = matrix_4x5.T\n\n# Optional outputs\nprint(\"Original array:\", array)\nprint(\"4x5 matrix:\\n\", matrix_4x5)\nprint(\"5x4 matrix:\\n\", matrix_5x4)\nprint(\"2x2x5 matrix:\\n\", matrix_2x2x5)\nprint(\"Flattened array:\", flattened_array)\nprint(\"Transposed 4x5 matrix:\\n\", transposed_matrix)\n\nOriginal array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]\n4x5 matrix:\n [[ 1  2  3  4  5]\n [ 6  7  8  9 10]\n [11 12 13 14 15]\n [16 17 18 19 20]]\n5x4 matrix:\n [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]\n [17 18 19 20]]\n2x2x5 matrix:\n [[[ 1  2  3  4  5]\n  [ 6  7  8  9 10]]\n\n [[11 12 13 14 15]\n  [16 17 18 19 20]]]\nFlattened array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]\nTransposed 4x5 matrix:\n [[ 1  6 11 16]\n [ 2  7 12 17]\n [ 3  8 13 18]\n [ 4  9 14 19]\n [ 5 10 15 20]]\n\n\n\n\nTask 9\nThe appropriate functions are np.loadtxt() and np.savetxt().\n\n\nTask 10\nImage data is typically stored as a 3D matrix, where each color component (usually red, green, and blue) is stored in a separate channel. If the image is stored in a matrix called data, you can isolate a color channel using slicing: data[:, :, 0], where 0, 1, or 2 selects the red, green, or blue channel respectively.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Learning Objective Check</span>"
    ]
  },
  {
    "objectID": "uebungen/uebung.html",
    "href": "uebungen/uebung.html",
    "title": "10  Übung",
    "section": "",
    "text": "10.1 Aufgabe 1 Filmdatenbank\nIn der ersten Aufgabe wollen wir fiktive Daten für Filmbewertungen untersuchen. Das Datenset ist dabei vereinfacht und beinhaltet folgende Spalten:\nHier ist das Datenset:\nimport numpy as np\n\nbewertungen = np.array([\n    [1, 101, 4.5],\n    [1, 102, 3.0],\n    [2, 101, 2.5],\n    [2, 103, 4.0],\n    [3, 101, 5.0],\n    [3, 104, 3.5],\n    [3, 105, 4.0]\n])",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "uebungen/uebung.html#aufgabe-1-filmdatenbank",
    "href": "uebungen/uebung.html#aufgabe-1-filmdatenbank",
    "title": "10  Übung",
    "section": "",
    "text": "Film ID\nBenutzer ID\nBewertung\n\n\n\n\n\n\n\n\n\na) Bestimmen Sie die jemals niedrigste und höchste Bewertung, die je gegeben wurde\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nniedrigste_bewertung = np.min(bewertungen[:,2])\n\nprint(\"Die niedrigste jemals gegebene Bertung ist:\", niedrigste_bewertung)\n\nhoechste_bewertung = np.max(bewertungen[:,2])\n\nprint(\"Die hoechste jemals gegebene Bertung ist:\", hoechste_bewertung)\n\nDie niedrigste jemals gegebene Bertung ist: 2.5\nDie hoechste jemals gegebene Bertung ist: 5.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb) Nennen Sie alle Bewertungen für Film 1\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen_film_1 = bewertungen[np.where(bewertungen[:,0]==1)]\n\nprint(\"Bewertungen für Film 1:\\n\", bewertungen_film_1)\n\nBewertungen für Film 1:\n [[  1.  101.    4.5]\n [  1.  102.    3. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nc) Nennen Sie alle Bewertungen von Person 101\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen_101 = bewertungen[np.where(bewertungen[:,1]==101)]\n\nprint(\"Bewertungen von Person 101:\\n\", bewertungen_101)\n\nBewertungen von Person 101:\n [[  1.  101.    4.5]\n [  2.  101.    2.5]\n [  3.  101.    5. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd) Berechnen Sie die mittlere Bewertung für jeden Film und geben Sie diese nacheinander aus\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nfor ID in [1, 2, 3]:\n\n    mittelwert = np.mean(bewertungen[np.where(bewertungen[:,0]==ID),2])\n\n    print(\"Die Mittlere Bewertung für Film\", ID, \"beträgt:\", mittelwert) \n\nDie Mittlere Bewertung für Film 1 beträgt: 3.75\nDie Mittlere Bewertung für Film 2 beträgt: 3.25\nDie Mittlere Bewertung für Film 3 beträgt: 4.166666666666667\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ne) Finden SIe den Film mit der höchsten Bewertung\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nindex_hoechste_bewertung = np.argmax(bewertungen[:,2])\n\nprint(bewertungen[index_hoechste_bewertung,:])\n\n[  3. 101.   5.]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf) Finden Sie die Person mit den meisten Bewertungen\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\neinzigartige_person, anzahl = np.unique(bewertungen[:, 1],return_counts=True)\n\nmeist_aktiver_person = einzigartige_person[np.argmax(anzahl)]\n\nprint(\"Personen mit den meisten Bewertungen:\", meist_aktiver_person)\n\nPersonen mit den meisten Bewertungen: 101.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ng) Nennen Sie alle Filme mit einer Wertung von 4 oder besser.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nindex_bewertung_besser_vier = bewertungen[:,2] &gt;= 4\n\nprint(\"Filme mit einer Wertung von 4 oder besser:\")\n\nprint(bewertungen[index_bewertung_besser_vier,:])\n\nFilme mit einer Wertung von 4 oder besser:\n[[  1.  101.    4.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  105.    4. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nh) Film Nr. 4 ist erschienen. Der Film wurde von Person 102 mit einer Note von 3.5 bewertet. Fügen Sie diesen zur Datenbank hinzu.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nneue_bewertung = np.array([4, 102, 3.5])\n\nbewertungen = np.append(bewertungen, [neue_bewertung], axis=0)\n\nprint(bewertungen)\n\n[[  1.  101.    4.5]\n [  1.  102.    3. ]\n [  2.  101.    2.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  104.    3.5]\n [  3.  105.    4. ]\n [  4.  102.    3.5]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni) Person 102 hat sich Film Nr. 1 nochmal angesehen und hat das Ende jetzt doch verstanden. Dementsprechend soll die Berwertung jetzt auf 5.0 geändert werden.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen[(bewertungen[:, 0] == 1) & \n            (bewertungen[:, 1] == 102), 2] = 5.0\n\nprint(\"Aktualisieren der Bewertung:\\n\", bewertungen)\n\nAktualisieren der Bewertung:\n [[  1.  101.    4.5]\n [  1.  102.    5. ]\n [  2.  101.    2.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  104.    3.5]\n [  3.  105.    4. ]\n [  4.  102.    3.5]]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "uebungen/uebung.html#aufgabe-2---kryptographie---caesar-chiffre",
    "href": "uebungen/uebung.html#aufgabe-2---kryptographie---caesar-chiffre",
    "title": "10  Übung",
    "section": "10.2 Aufgabe 2 - Kryptographie - Caesar-Chiffre",
    "text": "10.2 Aufgabe 2 - Kryptographie - Caesar-Chiffre\nIn dieser Aufgabe wollen wir Text sowohl ver- als auch entschlüsseln.\nJedes Zeichen hat über die sogenannte ASCII-Tabelle einen Zahlenwert zugeordnet.\n\n\n\n\n\n\nBuchstabe\nASCII Code\nBuchstabe\nASCII Code\n\n\n\n\na\n97\nn\n110\n\n\nb\n98\no\n111\n\n\nc\n99\np\n112\n\n\nd\n100\nq\n113\n\n\ne\n101\nr\n114\n\n\nf\n102\ns\n115\n\n\ng\n103\nt\n116\n\n\nh\n104\nu\n117\n\n\ni\n105\nv\n118\n\n\nj\n106\nw\n119\n\n\nk\n107\nx\n120\n\n\nl\n108\ny\n121\n\n\nm\n109\nz\n122\n\n\n\n\n\nTable 10.1: Ascii-Tabelle\n\n\n\nDer Einfachheit halber ist im Folgenden schon der Code zur Umwandlung von Buchstaben in Zahlenwerten und wieder zurück aufgeführt. Außerdem beschränken wir uns auf Texte mit kleinen Buchstaben.\nIhre Aufgabe ist nun die Zahlenwerte zu verändern.\nZunächste wollen wir eine einfache Caesar-Chiffre anwenden. Dabei werden alle Buchstaben um eine gewisse Anzahl verschoben. Ist Beispielsweise der der Verschlüsselungswert “1” wird aus einem A ein B, einem M, ein N. Ist der Wert “4” wird aus einem A ein E und aus einem M ein Q. Die Verschiebung findet zyklisch statt, das heißt bei einer Verschiebung von 1 wird aus einem Z ein A.\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return np.array([ord(c)])\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\n\n\n\n\n\n\n1. Überlegen Sie sich zunächst wie man diese zyklische Verschiebung mathematisch ausdrücken könnte (Hinweis: Modulo Rechnung)\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[ \\textrm{ASCII}_{\\textrm{verschoben}} = (\\textrm{ASCII} - 97 + \\textrm{Versatz}) \\textrm{ mod } 26 + 97\\]\n\n\n\n\n\n\n\n\n\n\n\n\n2. Schreiben Sie Code der mit einer Schleife alle Zeichen umwandelt.\n\n\n\n\n\nZunächst sollen alle Zeichen in Ascii Code umgewandelt werden. Dann wird die Formel auf die Zahlenwerte angewendet und schlussendlich in einer dritten schleife wieder alle Werte in Buchstaben übersetzt.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\nklartext = \"abrakadabra\"\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nverschluesselter_text= []\n\n\n\nfor buchstabe in klartext:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\n\nfor zahl in umgewandelter_text:    \n    verschluesselt = (zahl - 97 + versatz) % 26 + 97\n    verschluesselte_zahl.append(verschluesselt)\nprint(verschluesselte_zahl)\n\n\nfor zahl in verschluesselte_zahl:    \n    verschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(verschluesselter_text)\n\n[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]\n[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]\n['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. Ersetzen Sie die Schleife, indem Sie die Rechenoperation mit einem NumPy-Array durchführen\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\nklartext = \"abrakadabra\"\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nverschluesselter_text= []\n\n\n\nfor buchstabe in klartext:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\numgewandelter_text = np.array(umgewandelter_text)\nverschluesselte_zahl = (umgewandelter_text - 97 + versatz) % 26 + 97\nprint(verschluesselte_zahl)\n\nfor zahl in verschluesselte_zahl:    \n    verschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(verschluesselter_text)\n\n[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]\n[100 101 117 100 110 100 103 100 101 117 100]\n['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. Schreiben sie den Code so um, dass der verschlüsselte Text entschlüsselt wird.\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\n\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nentschluesselter_text= []\n\n\n\nfor buchstabe in verschluesselter_text:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\numgewandelter_text = np.array(umgewandelter_text)\nverschluesselte_zahl = (umgewandelter_text - 97 - versatz) % 26 + 97\nprint(verschluesselte_zahl)\n\nfor zahl in verschluesselte_zahl:    \n    entschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(entschluesselter_text)\n\n[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]\n[ 97  98 114  97 107  97 100  97  98 114  97]\n['a', 'b', 'r', 'a', 'k', 'a', 'd', 'a', 'b', 'r', 'a']",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "klausurfragen/klausurfragen_en.html",
    "href": "klausurfragen/klausurfragen_en.html",
    "title": "11  Exam Questions",
    "section": "",
    "text": "Exercise 1\nA rectangular concrete beam is subjected to a uniformly distributed load along its length. The stress distribution along the length of the beam shall be analyzed. The beam has a length of 10 meters, a width of 0.3 meters, and a height of 0.5 meters. The uniformly distributed load is 5000 N/m.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exam Questions</span>"
    ]
  },
  {
    "objectID": "klausurfragen/klausurfragen_en.html#exercise-1",
    "href": "klausurfragen/klausurfragen_en.html#exercise-1",
    "title": "11  Exam Questions",
    "section": "",
    "text": "Create a NumPy array x with 100 evenly spaced points along the length of the beam from 0 to 10 meters.\nCalculate the bending moments \\(M(x)\\) along the length of the beam using the formula: \\[\nM(x) = \\frac{w \\cdot x \\cdot (L - x)}{2}\n\\] where \\(w\\) is the distributed load (in N/m), \\(x\\) is the position along the beam (in m), and \\(L\\) is the length of the beam (in m).\nCompute the maximum bending stress \\(\\sigma_{\\text{max}}(x)\\) at each point along the beam using the formula: \\[\n\\sigma_{\\text{max}}(x) = \\frac{M(x) \\cdot c}{I}\n\\] where \\(c\\) is the distance from the neutral axis to the outermost fiber of the beam (in m), and \\(I\\) is the moment of inertia.\nThe moment of inertia of a rectangular cross-section is given by: \\[\nI = \\frac{b \\cdot h^3}{12}\n\\] where \\(b\\) is the width (in m) and \\(h\\) is the height of the beam (in m).\nDetermine the maximum bending stress.\nPlot the stress distribution \\(\\sigma_{\\text{max}}(x)\\) along the length of the beam.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exam Questions</span>"
    ]
  }
]