{
  "hash": "071b35a981eef6569d97c08fa261b0b0",
  "result": {
    "engine": "jupyter",
    "markdown": "# Working with Arrays\n\n## Arithmetic Functions\n\n\n\nOne major advantage of NumPy is working with arrays. Without NumPy, you would\neither have to use a `loop` or a `list comprehension` to perform operations on\nall values in a list. NumPy eliminates this inconvenience.\n\n::: {#703552d7 .cell execution_count=2}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 8, 7, 6, 5])\n```\n:::\n\n\nBasic mathematical operations like addition can be expressed in two ways:\neither using the `np.add()` function or simply with the `+` operator.\n\n::: {#fc9991f0 .cell execution_count=3}\n``` {.python .cell-code}\nnp.add(a,b)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\n::: {#76a8e6ce .cell execution_count=4}\n``` {.python .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\nWithout NumPy, the operation would look like this:\n\n::: {#94e30d35 .cell execution_count=5}\n``` {.python .cell-code}\nresult = np.ones(5)\nfor i in range(len(a)):\n    result[i] = a[i] + b[i]\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10. 10. 10. 10. 10.]\n```\n:::\n:::\n\n\nFor other types of arithmetic, there are functions like: `np.subtract()`,\n`np.multiply()`, and `np.divide()`.\n\nHigher-level mathematical operations also have functions:\n\n* `np.exp(a)`\n* `np.sqrt(a)`\n* `np.power(a, 3)`\n* `np.sin(a)`\n* `np.cos(a)`\n* `np.tan(a)`\n* `np.log(a)`\n* `a.dot(b)`\n\n::: {.callout-warning}\n\n## Working with Trigonometric Functions\n\nJust like with a calculator, a common error when using trigonometric functions\n(sin, cos, ...) is to input degrees instead of radians. However, the trigonometric\nfunctions in NumPy expect values in radians.\n\nTo easily convert between degrees and radians, NumPy provides the functions \n`np.deg2rad()` and `np.rad2deg()`.\n\n:::\n\n## Comparisons\n\nNumPy arrays can also be compared with one another. Letâ€™s look at the following\ntwo arrays:\n\n::: {#2fcf2c51 .cell execution_count=6}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 2, 7, 4, 5])\n```\n:::\n\n\nTo check whether these arrays are identical, we can use the `==` comparator.\nThis compares the arrays element-wise.\n\n::: {#a48f698f .cell execution_count=7}\n``` {.python .cell-code}\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([False,  True, False,  True,  True])\n```\n:::\n:::\n\n\nYou can also compare arrays using the `>` and `<` operators:\n\n::: {#e48130ce .cell execution_count=8}\n``` {.python .cell-code}\na < b\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([ True, False,  True, False, False])\n```\n:::\n:::\n\n\nWhen comparing arrays with floating point numbers, it is often necessary to \nallow for some tolerance due to small rounding errors in computations.\n\n::: {#95efe065 .cell execution_count=9}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.False_\n```\n:::\n:::\n\n\nFor this case, NumPy offers a comparison function `np.isclose(a,b,atol)`, where \n`atol` stands for absolute tolerance. In the following example, an absolute \ntolerance of 0.001 is used.\n\n::: {#341457dd .cell execution_count=10}\n``` {.python .cell-code}\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\nprint(np.isclose(a, b, atol=0.001))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\n## Why is 0.1 + 0.2 not equal to 0.3?\n\nNumbers are internally represented in binary. Just like 1/3 cannot be \nrepresented precisely with a finite number of decimal digits, some numbers \nmust be rounded in binary representation.\n\n::: {#d39505ba .cell execution_count=11}\n``` {.python .cell-code}\na = 0.1\nb = 0.2\nprint(a + b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n:::\n\n## Aggregation Functions\n\nFor many types of analysis, we need functions such as sum or mean. Letâ€™s start\nwith an example array `a`:\n\n::: {#0f05cf5c .cell execution_count=12}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 8])\n```\n:::\n\n\nThe sum is calculated using the `np.sum()` function.\n\n::: {#ddb21925 .cell execution_count=13}\n``` {.python .cell-code}\nnp.sum(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nnp.int64(18)\n```\n:::\n:::\n\n\nOf course, you can also determine the minimum and maximum of an array. The \nfunctions are `np.min()` and `np.max()`.\n\n::: {#734c2d34 .cell execution_count=14}\n``` {.python .cell-code}\nnp.min(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nnp.int64(1)\n```\n:::\n:::\n\n\nIf you want the position of the maximum value instead of the value itself, use\n`np.argmax` instead of `np.max`.\n\nFor statistical analysis, common functions are `np.mean()` for the mean,\n`np.median()` for the median, and `np.std()` for the standard deviation.\n\n::: {#3a70beca .cell execution_count=15}\n``` {.python .cell-code}\nnp.mean(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nnp.float64(3.6)\n```\n:::\n:::\n\n\n::: {#5c7a6f84 .cell execution_count=16}\n``` {.python .cell-code}\nnp.median(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nnp.float64(3.0)\n```\n:::\n:::\n\n\n::: {#9003281b .cell execution_count=17}\n``` {.python .cell-code}\nnp.std(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nnp.float64(2.4166091947189146)\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Exercise: Working with Arrays\n\nGiven two one-dimensional arrays `a` and `b`:\n\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) and  \nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n1. Create a new array that contains the sine values of the added arrays `a` and `b`.\n2. Calculate the sum, mean, and standard deviation of the elements in `a`.\n3. Find the largest and smallest values in both `a` and `b`.\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Solution\n\n::: {#ef605fef .cell execution_count=18}\n``` {.python .cell-code}\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n# 1.\nsin_ab = np.sin(a + b)\n\n# 2.\nsum_a = np.sum(a)\nmean_a = np.mean(a)\nstd_a = np.std(a)\n\n# 3.\nmax_a = np.max(a)\nmin_a = np.min(a)\nmax_b = np.max(b)\nmin_b = np.min(b)\n```\n:::\n\n\n:::\n:::\n\n",
    "supporting": [
      "array_calculation_en_files"
    ],
    "filters": [],
    "includes": {}
  }
}