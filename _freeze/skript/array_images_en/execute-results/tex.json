{
  "hash": "ebe6dcc54a8c1c75eb5cb56fd4d6adfd",
  "result": {
    "engine": "jupyter",
    "markdown": "## Working with Images\n\n\n\nImages are digitally stored as matrices. Each pixel contains three color values: red, green, and blue. These three values (ranging from 0–255) are combined to produce all desired colors.\n\n![A high-resolution image consists of many pixels. Each pixel contains 3 color values: one each for green, blue, and red.](../skript/00-bilder/pixel_mona_lisa_split.svg){#fig-pixel_colors fig-alt=\"Diagram showing that a high-resolution image of the Mona Lisa consists of individual pixels, which in turn are composed of the three colors blue, red, and green.\"}\n\nThanks to the digital nature of images, they can be easily processed using NumPy tools. In the following example, we use the Mona Lisa as our image. It can be found at this [link](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Mona_Lisa.jpg/677px-Mona_Lisa.jpg).\n\nLet’s import this image using the `imread()` function from the matplotlib package. You'll see that it is a three-dimensional NumPy array.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ndata = plt.imread(\"00-bilder/mona_lisa.jpg\")\nprint(\"Shape:\", data.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape: (1024, 677, 3)\n```\n:::\n:::\n\n\nLet’s take a look at a snippet of the data using the `print()` function.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 68  62  38]\n  [ 88  82  56]\n  [ 92  87  55]\n  ...\n  [ 54  97  44]\n  [ 68 110  60]\n  [ 69 111  63]]\n\n [[ 65  59  33]\n  [ 68  63  34]\n  [ 83  78  46]\n  ...\n  [ 66 103  51]\n  [ 66 103  52]\n  [ 66 102  56]]\n\n [[ 97  90  62]\n  [ 87  80  51]\n  [ 78  72  38]\n  ...\n  [ 79 106  53]\n  [ 62  89  38]\n  [ 62  88  41]]\n\n ...\n\n [[ 25  14  18]\n  [ 21  10  14]\n  [ 20   9  13]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 23  12  16]\n  [ 23  12  16]\n  [ 21  10  14]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 22  11  15]\n  [ 26  15  19]\n  [ 24  13  17]\n  ...\n  [ 11   5   9]\n  [ 10   4   8]\n  [  9   3   7]]]\n```\n:::\n:::\n\n\nUsing the `plt.imshow` function, the image can be displayed in true color. This works because the function interprets the last index of the dataset as color information (red, green, blue). If there were a fourth layer, it would be interpreted as an individual transparency value.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nplt.imshow(data)\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-5-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nOf course, the individual color channels can also be viewed separately. We do this by fixing the last index. Here we look only at the red component of the image. When displaying a simple array, the output is in grayscale. With the option `cmap='Reds'`, we can adjust the color scale.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Use the red color scale 'Reds'\nplt.imshow(data[:,:,0], cmap='Reds')\nplt.colorbar()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-6-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nSince the image data is stored as arrays, many operations such as slicing or other computations are possible. The example below shows a cropped area of the red channel.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nregion = np.array(data[450:500, 550:600, 0], dtype=float)\nplt.imshow(region, cmap=\"Greys\")\nplt.colorbar()\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-7-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow let’s consider a more complex operation on image data, the [Laplace operator](https://en.wikipedia.org/wiki/Laplace_operator). It can be used to detect the edges of objects. For each pixel $B_{i,j}$ – except those at the border – the following value $\\phi_{i,j}$ is computed:\n\n$$ \\phi_{i, j} = \\left|B_{i-1, j} + B_{i, j-1} - 4\\cdot B_{i, j} + B_{i+1, j} + B_{i, j+1}\\right| $$\n\nThe following function implements this operation. In addition, all values of $\\phi$ below a threshold are set to zero, and those above are set to 255.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef img_lap(data, threshold=25):\n    \n    # Create a copy of the data as a float array\n    region = np.array(data, dtype=float)\n    \n    # Split the equation into two parts\n    lapx = region[2:, :] - 2 * region[1:-1, :] + region[:-2, :]\n    lapy = region[:, 2:] - 2 * region[:, 1:-1] + region[:, :-2]\n    \n    # Combine the parts and take the absolute value\n    lap = np.abs(lapx[:,1:-1] + lapy[1:-1, :])\n    \n    # Thresholding\n    lap[lap > threshold] = 255\n    lap[lap < threshold] = 0\n    \n    return lap\n```\n:::\n\n\nNow let’s examine a photo of the Haspel Campus in Wuppertal: [Image](https://firedynamics.github.io/LectureComputerScience/_downloads/592f1fc843fc7c01bdcad17bf85ec15c/campus_haspel.jpeg). Applying the Laplace operator to a cropped section gives the following result:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndata = plt.imread('01-daten/campus_haspel.jpeg')\nregion = np.array(data[1320:1620, 400:700, 1], dtype=float)\n\nlap = img_lap(region)\n\nplt.figure(figsize=(9, 3))\n\nax = plt.subplot(1, 3, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 3, 2)\nax.imshow(region, cmap=\"Greys_r\");\n\nax = plt.subplot(1, 3, 3)\nax.imshow(lap, cmap=\"Greys\");\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-9-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nWe can now clearly see the outlines of the window.\n\nIf we want to edit a color component and then reassemble the image, we use the function `np.dstack((red, green, blue)).astype('uint8')`, where `red`, `green`, and `blue` are the individual 2D arrays. Let’s try removing the green color from the tree on the left.\n\nIt’s important that the data is in `uint8` format after recombining, which is why we use `.astype('uint8')`.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\n# Store individual color channels in arrays\nred = np.array(data[:, :, 0], dtype=float)\ngreen = np.array(data[:, :, 1], dtype=float)\nblue = np.array(data[:, :, 2], dtype=float)\n\n# Set the green area of the tree on the left to 0\ngreen_new = green.copy()\ngreen_new[800:2000, 700:1700] = 0\n\ncomposed = np.dstack((red, green_new, blue)).astype('uint8')\n\nplt.figure(figsize=(8, 5))\n\nax = plt.subplot(1, 2, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 2, 2)\nax.imshow(composed)\n```\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-10-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Mini Exercise: Image Manipulation\n\nLoad the following image of the Haspel Campus in Wuppertal:  \n[Image](https://firedynamics.github.io/LectureComputerScience/_downloads/592f1fc843fc7c01bdcad17bf85ec15c/campus_haspel.jpeg)\n\nExtract the blue component and display the middle row of the image, as well as any selected image section.\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Solution\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\nshape = data.shape\nprint(\"Shape:\", shape)\n\nblue = data[:,:,2]\nplt.imshow(blue, cmap='Blues')\n\nrow = data[int(shape[0]/2), :, 2]\nprint(row)\n\ncrop = data[10:50, 10:50, :]\nplt.imshow(crop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape: (3024, 4032, 3)\n[221 220 220 ...  28  28  28]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](array_images_en_files/figure-pdf/cell-11-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_images_en_files/figure-pdf"
    ],
    "filters": []
  }
}